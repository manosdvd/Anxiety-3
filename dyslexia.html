<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Dyslexia - Word Hunt</title>
  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Black+Ops+One&family=Courier+Prime:wght@400;700&display=swap');

    html,
    body,
    #root {
      height: 100%;
      margin: 0;
      overflow: hidden;
    }

    body {
      background-color: #0f0f0f;
      color: #ffffff;
      font-family: 'Courier Prime', monospace;
      touch-action: none;
    }

    .block {
      transition: transform 0.1s linear, top 0.1s linear;
    }

    .shake {
      animation: shake 0.5s cubic-bezier(.36, .07, .19, .97) both;
    }

    @keyframes shake {
      10%, 90% { transform: translate3d(-1px, 0, 0); }
      20%, 80% { transform: translate3d(2px, 0, 0); }
      30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
      40%, 60% { transform: translate3d(4px, 0, 0); }
    }

    .level-up-anim { animation: levelUpScale 0.5s ease-out; }

    @keyframes levelUpScale {
      0% { transform: scale(1); color: #fff; }
      50% { transform: scale(1.5); color: #fbbf24; }
      100% { transform: scale(1); color: #fff; }
    }

    .pulse-red { animation: pulse-red 1s infinite; }

    @keyframes pulse-red {
      0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
      100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
    }

    /* CRT Scanline effect */
    .scanlines {
      background: linear-gradient(to bottom,
          rgba(255, 255, 255, 0),
          rgba(255, 255, 255, 0) 50%,
          rgba(0, 0, 0, 0.2) 50%,
          rgba(0, 0, 0, 0.2));
      background-size: 100% 4px;
      position: absolute;
      top: 0; right: 0; bottom: 0; left: 0;
      pointer-events: none;
      z-index: 50;
    }

    /* Selection Indicator */
    .selected-ring { animation: spin 4s linear infinite; }

    @keyframes spin { 100% { transform: rotate(360deg); } }

    /* Explosion Particles */
    .particle {
      position: absolute;
      pointer-events: none;
      animation: explode 0.6s ease-out forwards;
    }

    @keyframes explode {
      0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
      100% { transform: translate(var(--tx), var(--ty)) scale(0); opacity: 0; }
    }

    /* Floating Score */
    .floating-score {
      position: absolute;
      pointer-events: none;
      animation: floatUp 1s ease-out forwards;
      font-weight: bold;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      z-index: 40;
      white-space: nowrap;
    }

    @keyframes floatUp {
      0% { transform: translate(-50%, -50%) scale(0.5); opacity: 0; }
      20% { transform: translate(-50%, -120%) scale(1.2); opacity: 1; }
      100% { transform: translate(-50%, -250%) scale(1); opacity: 0; }
    }

    .grid-container {
      display: grid;
      grid-template-columns: repeat(8, 1fr);
      grid-template-rows: repeat(10, 1fr);
      gap: 4px;
      width: 100%; height: 100%;
      max-width: 100%; max-height: 100%;
      aspect-ratio: 4/5;
      margin: 0 auto;
    }

    /* Powerup Styles */
    .powerup-btn {
      transition: all 0.2s ease;
      position: relative;
      overflow: hidden;
    }
    .powerup-available {
      border-color: #60A5FA;
      background-color: rgba(30, 58, 138, 0.6);
      color: #ffffff;
      box-shadow: 0 0 10px rgba(37, 99, 235, 0.3);
    }
    .powerup-active {
      border-color: #FBBF24 !important;
      background-color: rgba(251, 191, 36, 0.25) !important;
      color: #FBBF24 !important;
      box-shadow: 0 0 15px #FBBF24 !important;
      transform: translateY(-2px);
    }
    .powerup-disabled {
      border-color: #374151;
      background-color: #1F2937;
      color: #4B5563;
      opacity: 0.5;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    const { useState, useEffect, useRef, useCallback } = React;

    // --- Icons ---
    const IconRadius = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><circle cx="12" cy="12" r="10" /><path d="m22 12-4 0" /><path d="m6 12-4 0" /><path d="m12 6-4 0" /><path d="m12 22-4 0" /></svg>;
    const IconCol = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19" /><polyline points="19 12 12 19 5 12" /></svg>;
    const IconRow = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12" /><polyline points="12 5 19 12 12 19" /></svg>;
    const IconX = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="18" y1="6" x2="6" y2="18" /><line x1="6" y1="6" x2="18" y2="18" /></svg>;
    const IconColor = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M12 2.69l5.74 5.74c.84.84 1.26 1.26 1.26 2.07 0 .81-.42 1.23-1.26 2.07L12 18.31l-5.74-5.74C5.42 11.73 5 11.31 5 10.5c0-.81.42-1.23 1.26-2.07L12 2.69z" /><path d="M12 22a7 7 0 0 0 7-7v-1.5" /><path d="M12 22a7 7 0 0 1-7-7v-1.5" /><path d="M12 22v-9" /></svg>;
    const IconPause = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="6" y="4" width="4" height="16" /><rect x="14" y="4" width="4" height="16" /></svg>;
    const IconVolume = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5" /><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07" /></svg>;
    const IconVolumeOff = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><line x1="1" y1="1" x2="23" y2="23" /><path d="M9 9v6a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6" /></svg>;
    const IconZap = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2" /></svg>;
    const IconBack = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="19" y1="12" x2="5" y2="12" /><polyline points="12 19 5 12 12 5" /></svg>;
    const IconMonitor = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><rect x="2" y="3" width="20" height="14" rx="2" ry="2" /><line x1="8" y1="21" x2="16" y2="21" /><line x1="12" y1="17" x2="12" y2="21" /></svg>;
    const IconEye = () => <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round"><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z" /><circle cx="12" cy="12" r="3" /></svg>;
    const IconMinus = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="5" y1="12" x2="19" y2="12" /></svg>;
    const IconPlus = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><line x1="12" y1="5" x2="12" y2="19" /><line x1="5" y1="12" x2="19" y2="12" /></svg>;
    const IconCheck = () => <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="3" strokeLinecap="round" strokeLinejoin="round"><polyline points="20 6 9 17 4 12" /></svg>;

    // --- Audio Context ---
    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // --- Constants ---
    const ROWS = 10;
    const COLS = 8;
    const LETTERS = "EEEEEEEEEEEEAAAAAAAAAIIIIIIIIIOOOOOOOONNNNNNRRRRRRTTTTTTLLLLSSSSUUUDDDDGGGBBCCMMPPFFHHVVWWYYKJXQZ";
    const LETTER_SCORES = { E: 1, A: 1, I: 1, O: 1, N: 1, R: 1, T: 1, L: 1, S: 1, U: 1, D: 2, G: 2, B: 3, C: 3, M: 3, P: 3, F: 4, H: 4, V: 4, W: 4, Y: 4, K: 5, J: 8, X: 8, Q: 10, Z: 10 };
    const COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e', '#3b82f6', '#a855f7', '#ec4899'];

    // --- Difficulty Logic ---
    const getTickRateForLevel = (lvl) => {
      // Tetris-like curve
      if (lvl < 5) return 1200 - ((lvl - 1) * 200);
      if (lvl < 10) return 400 - ((lvl - 5) * 50);
      const progress = (lvl - 10) / 5;
      return Math.floor(180 * (1 - progress) + 60 * progress);
    };

    const getThresholdForLevel = (lvl) => 1000 + (lvl * 250);

    const generateBlock = (row, col) => {
      const letter = LETTERS[Math.floor(Math.random() * LETTERS.length)];
      return {
        id: Math.random().toString(36).substr(2, 9),
        letter: letter,
        score: LETTER_SCORES[letter],
        color: COLORS[Math.floor(Math.random() * COLORS.length)],
        row, col, isFalling: false, isNew: false
      };
    };

    const App = () => {
      // Settings
      const [settings, setSettings] = useState({ sound: true, haptics: true, crt: true, colorBlind: false });
      const [isPaused, setIsPaused] = useState(false);

      // Game State
      const [board, setBoard] = useState([]);
      const [previewRow, setPreviewRow] = useState(Array(8).fill(null));
      const [score, setScore] = useState(0);
      const [highScore, setHighScore] = useState(parseInt(localStorage.getItem('dyslexia_highscore')) || 0);
      const [level, setLevel] = useState(1);
      const [startLevel, setStartLevel] = useState(1);
      const [levelScore, setLevelScore] = useState(0);
      const [gameOver, setGameOver] = useState(false);
      const [gameStarted, setGameStarted] = useState(false);
      const [shake, setShake] = useState(false);
      const [levelAnim, setLevelAnim] = useState(false);
      const [particles, setParticles] = useState([]);
      const [floatingTexts, setFloatingTexts] = useState([]);

      const [inventory, setInventory] = useState({ radius: 0, col: 0, row: 0, x: 0, color: 0 });
      const [activeTool, setActiveTool] = useState(null);
      const [comboChain, setComboChain] = useState(0);

      const [tickRate, setTickRate] = useState(1200);
      const [previewIndex, setPreviewIndex] = useState(0);
      const timerRef = useRef(null);

      // --- Word Logic ---
      const [currentWord, setCurrentWord] = useState([]);
      const [dictionary, setDictionary] = useState(new Set());
      const [dictLoaded, setDictLoaded] = useState(false);
      const [loadingError, setLoadingError] = useState(null);

      // Load Dictionary
      useEffect(() => {
          fetch('https://raw.githubusercontent.com/dwyl/english-words/master/words_alpha.txt')
              .then(res => {
                  if (!res.ok) throw new Error('Failed to load dictionary');
                  return res.text();
              })
              .then(text => {
                  const words = new Set(text.split('\n').map(w => w.trim().toUpperCase()).filter(w => w.length >= 3));
                  setDictionary(words);
                  setDictLoaded(true);
              })
              .catch(err => {
                  console.error(err);
                  setLoadingError("Failed to load dictionary. Check connection.");
              });
      }, []);

      // --- Helpers ---
      const triggerHaptic = (pattern) => {
        if (settings.haptics && navigator.vibrate) navigator.vibrate(pattern);
      };

      const playTone = (freq, type, duration, vol = 0.1) => {
        if (!settings.sound) return;
        if (audioCtx.state === 'suspended') audioCtx.resume();
        const osc = audioCtx.createOscillator();
        const gain = audioCtx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
        gain.gain.setValueAtTime(vol, audioCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + duration);
        osc.connect(gain);
        gain.connect(audioCtx.destination);
        osc.start();
        osc.stop(audioCtx.currentTime + duration);
      };

      const playMatchSound = (combo) => {
        const baseFreq = 300 + (combo * 100);
        playTone(baseFreq, 'sine', 0.3, 0.2);
        playTone(baseFreq * 1.5, 'triangle', 0.1, 0.1);
      };
      const playExplosionSound = () => {
        playTone(100, 'sawtooth', 0.4, 0.3);
        setTimeout(() => playTone(80, 'square', 0.4, 0.3), 50);
      };
      const playDropSound = () => playTone(100, 'square', 0.1, 0.05);
      const playTickSound = (i) => playTone(400 + (i * 100), 'sawtooth', 0.05, 0.05);
      const playSelectSound = () => playTone(600, 'sine', 0.05, 0.1);
      const playErrorSound = () => { playTone(150, 'sawtooth', 0.2, 0.2); setTimeout(()=> playTone(100, 'sawtooth', 0.2, 0.2), 100); };
      const playLevelUpSound = () => {
        playTone(400, 'square', 0.1, 0.2);
        setTimeout(() => playTone(600, 'square', 0.1, 0.2), 100);
        setTimeout(() => playTone(800, 'square', 0.2, 0.2), 200);
      };
      const playGameOverSound = () => {
        playTone(150, 'sawtooth', 1, 0.3);
        setTimeout(() => playTone(100, 'sawtooth', 1, 0.3), 200);
      };

      // Init
      const initGame = () => {
        const newBoard = [];
        for (let r = 0; r < ROWS; r++) {
          const row = [];
          for (let c = 0; c < COLS; c++) {
            if (r >= ROWS - 5) {
              row.push(generateBlock(r, c));
            } else row.push(null);
          }
          newBoard.push(row);
        }
        setBoard(newBoard);
        setPreviewRow(Array(8).fill(null));
        setPreviewIndex(0);
        setScore(0);
        setLevel(startLevel);
        setLevelScore(0);
        setInventory({ radius: 0, col: 0, row: 0, x: 0, color: 0 });
        setGameOver(false);
        setGameStarted(true);
        setTickRate(getTickRateForLevel(startLevel));
        setCurrentWord([]);
        setParticles([]);
        setFloatingTexts([]);
        setActiveTool(null);
        setComboChain(0);
        setIsPaused(false);
      };

      // Effects
      const createExplosion = (r, c, color) => {
        const newParticles = [];
        for (let i = 0; i < 8; i++) {
          const angle = (Math.PI * 2 * i) / 8;
          newParticles.push({
            id: Math.random(), r, c, color,
            tx: Math.cos(angle) * 100 + 'px',
            ty: Math.sin(angle) * 100 + 'px'
          });
        }
        setParticles(prev => [...prev, ...newParticles]);
        setTimeout(() => setParticles(prev => prev.filter(p => !newParticles.includes(p))), 600);
      };

      const showFloatingText = (r, c, text, color = '#fff') => {
        const id = Math.random();
        const offsetX = (Math.random() - 0.5) * 20;
        const offsetY = (Math.random() - 0.5) * 20;
        setFloatingTexts(prev => [...prev, { id, r, c, text, color, offsetX, offsetY }]);
        setTimeout(() => setFloatingTexts(prev => prev.filter(t => t.id !== id)), 1200);
      };

      // Leveling Logic
      useEffect(() => {
        if (!gameStarted) return;
        const threshold = getThresholdForLevel(level);

        if (levelScore >= threshold) {
          const newLevel = level + 1;
          setLevel(newLevel);
          setLevelScore(0); // Reset progress bar for next level

          playLevelUpSound();
          triggerHaptic([100, 50, 100]);
          setLevelAnim(true);
          setTimeout(() => setLevelAnim(false), 500);

          const bombTypes = ['radius', 'col', 'row', 'x', 'color'];
          const reward = bombTypes[Math.floor(Math.random() * bombTypes.length)];
          setInventory(prev => ({ ...prev, [reward]: prev[reward] + 1 }));

          showFloatingText(ROWS / 2 - 2, COLS / 2, `LEVEL ${newLevel}!`, '#FFFFFF');
          setTimeout(() => {
            showFloatingText(ROWS / 2 + 1, COLS / 2, `+1 ${reward.toUpperCase()} BOMB`, '#FBBF24');
          }, 200);

          setTickRate(getTickRateForLevel(newLevel));
        }
        if (score > highScore) {
          setHighScore(score);
          localStorage.setItem('dyslexia_highscore', score);
        }
      }, [levelScore, gameStarted, level, score, highScore]);

      // Timers
      useEffect(() => {
        if (!gameStarted || gameOver || isPaused) {
          if (timerRef.current) clearInterval(timerRef.current);
          return;
        }
        timerRef.current = setInterval(() => fillPreviewSlot(), tickRate);
        return () => clearInterval(timerRef.current);
      }, [gameStarted, gameOver, isPaused, tickRate, previewIndex, previewRow]);

      const fillPreviewSlot = () => {
        setPreviewIndex(prev => {
          if (prev >= COLS) { dropPreviewRow(); return 0; }
          setPreviewRow(curr => {
            const newRow = [...curr];
            newRow[prev] = generateBlock(-1, prev);
            return newRow;
          });
          playTickSound(prev);
          return prev + 1;
        });
      };

      const dropPreviewRow = () => {
        setBoard(cur => {
          for (let c = 0; c < COLS; c++) if (cur[0][c]) { handleGameOver(); return cur; }
          return cur;
        });
        performDrop();
      };

      const performDrop = () => {
        setPreviewRow(prev => {
          setBoard(cur => {
            for (let c = 0; c < COLS; c++) if (cur[0][c]) { handleGameOver(); return cur; }
            const nb = cur.map(r => [...r]);
            for (let c = 0; c < COLS; c++) if (prev[c]) nb[0][c] = { ...prev[c], row: 0, col: c };
            playDropSound();
            return nb;
          });
          triggerHaptic(50);
          return Array(8).fill(null);
        });
      };

      const handleGameOver = () => {
        setGameOver(true); setGameStarted(false); setIsPaused(false);
        playGameOverSound(); triggerHaptic(1000);
        setShake(true); setTimeout(() => setShake(false), 500);
      };

      // Physics Loop
      useEffect(() => {
        if (!gameStarted || gameOver || isPaused) return;
        const int = setTimeout(() => {
          applyGravity();
        }, 65);
        return () => clearTimeout(int);
      }, [board, gameStarted, gameOver, isPaused, comboChain]);

      const applyGravity = () => {
        let moved = false;
        const nb = board.map(r => [...r]);
        for (let c = 0; c < COLS; c++) {
          for (let r = ROWS - 2; r >= 0; r--) {
            if (nb[r][c] && !nb[r + 1][c]) {
              nb[r + 1][c] = { ...nb[r][c], row: r + 1 }; nb[r][c] = null; moved = true;

              // Update currentWord references if blocks move
              setCurrentWord(prev => prev.map(b => b.id === nb[r + 1][c].id ? nb[r + 1][c] : b));
            }
          }
        }
        if (moved) setBoard(nb);
        return moved;
      };

      // --- Bomb Logic ---
      const activateTool = (t) => {
        if (activeTool === t) setActiveTool(null);
        else if (inventory[t] > 0) { setActiveTool(t); setCurrentWord([]); }
      };

      const detonateBomb = (r, c) => {
        if (!activeTool || inventory[activeTool] <= 0) return;
        const nb = board.map(row => [...row]);
        let destroyed = 0;
        const destroy = (tr, tc) => {
          if (tr >= 0 && tr < ROWS && tc >= 0 && tc < COLS && nb[tr][tc]) {
            createExplosion(tr, tc, nb[tr][tc].color);
            nb[tr][tc] = null; destroyed++;
          }
        };

        if (activeTool === 'radius') {
          for (let i = r - 2; i <= r + 2; i++) for (let j = c - 2; j <= c + 2; j++) if (Math.sqrt((i - r) ** 2 + (j - c) ** 2) < 2.5) destroy(i, j);
        } else if (activeTool === 'col') {
          for (let i = 0; i < ROWS; i++) destroy(i, c);
        } else if (activeTool === 'row') {
          for (let j = 0; j < COLS; j++) destroy(r, j);
        } else if (activeTool === 'x') {
          for (let k = -Math.max(ROWS, COLS); k < Math.max(ROWS, COLS); k++) { destroy(r + k, c + k); destroy(r + k, c - k); }
        } else if (activeTool === 'color') {
          const targetColor = board[r][c]?.color;
          if (targetColor) for (let i = 0; i < ROWS; i++) for (let j = 0; j < COLS; j++) if (nb[i][j]?.color === targetColor) destroy(i, j);
        }

        playExplosionSound(); triggerHaptic(200);
        setShake(true); setTimeout(() => setShake(false), 500);
        setBoard(nb);
        setInventory(prev => ({ ...prev, [activeTool]: prev[activeTool] - 1 }));
        setActiveTool(null);

        const pts = destroyed * 5;
        setScore(prev => prev + pts);
        setLevelScore(prev => prev + pts);
        showFloatingText(r, c, "BOOM!", "#ef4444");
        showFloatingText(r, c, `+${pts}`, "#FBBF24");
      };

      // --- Interaction ---
      const handleBlockClick = (r, c) => {
        if (gameOver || !gameStarted || isPaused) return;
        if (activeTool) { detonateBomb(r, c); return; }

        const blk = board[r][c];
        if (!blk) return;

        // Check if already selected
        const idx = currentWord.findIndex(b => b.id === blk.id);
        if (idx !== -1) {
            // If clicking the last selected block, deselect it
            if (idx === currentWord.length - 1) {
                 setCurrentWord(prev => prev.slice(0, -1));
                 playSelectSound();
            } else {
                // Deselect everything after this block
                setCurrentWord(prev => prev.slice(0, idx + 1));
                playSelectSound();
            }
        } else {
            // Add to selection
            setCurrentWord(prev => [...prev, blk]);
            playSelectSound();
            triggerHaptic(10);
        }
      };

      const clearWord = () => {
        setCurrentWord([]);
        playSelectSound();
      };

      const submitWord = () => {
        if (currentWord.length < 3) {
            playErrorSound();
            setShake(true); setTimeout(() => setShake(false), 300);
            return;
        }

        const word = currentWord.map(b => b.letter).join('');
        if (dictionary.has(word)) {
            // Calculate Score
            let wordScore = currentWord.reduce((acc, b) => acc + b.score, 0);
            wordScore *= currentWord.length; // Length multiplier

            setScore(s => s + wordScore);
            setLevelScore(s => s + wordScore);
            playMatchSound(1);
            triggerHaptic([50, 50]);

            // Remove blocks
            const nb = board.map(r => [...r]);
            currentWord.forEach(b => {
                // Double check if block still exists at location (it should)
                if (nb[b.row][b.col] && nb[b.row][b.col].id === b.id) {
                    createExplosion(b.row, b.col, b.color);
                    nb[b.row][b.col] = null;
                }
            });
            setBoard(nb);
            setCurrentWord([]);
            showFloatingText(currentWord[0].row, currentWord[0].col, `${word} +${wordScore}`, '#FBBF24');
            setShake(true); setTimeout(() => setShake(false), 300);
        } else {
            playErrorSound();
            setShake(true); setTimeout(() => setShake(false), 300);
            showFloatingText(currentWord[currentWord.length - 1].row, currentWord[currentWord.length - 1].col, "UNKNOWN", '#ef4444');
        }
      };

      // --- UI Handlers ---
      const togglePause = () => setIsPaused(prev => !prev);
      const toggleSound = () => setSettings(s => ({ ...s, sound: !s.sound }));
      const toggleHaptics = () => setSettings(s => ({ ...s, haptics: !s.haptics }));
      const toggleCRT = () => setSettings(s => ({ ...s, crt: !s.crt }));
      const toggleColorBlind = () => setSettings(s => ({ ...s, colorBlind: !s.colorBlind }));

      const adjustStartLevel = (delta) => {
        setStartLevel(prev => Math.max(1, Math.min(15, prev + delta)));
      };

      const ToolBtn = ({ type, icon: Icon, label }) => (
        <button
          onClick={() => activateTool(type)}
          disabled={inventory[type] === 0 || isPaused}
          className={`
                        powerup-btn flex flex-col items-center justify-center w-12 h-14 rounded border-2
                        ${activeTool === type ? 'powerup-active' : ''}
                        ${inventory[type] > 0 && activeTool !== type ? 'powerup-available' : ''}
                        ${inventory[type] === 0 ? 'powerup-disabled' : ''}
                    `}
        >
          <Icon />
          <span className="text-[10px] font-bold mt-1 leading-none">{label}</span>
          <div className="absolute top-0 right-0 bg-black/50 px-1 text-[9px]">{inventory[type]}</div>
        </button>
      );

      const SettingBtn = ({ label, active, onClick, icon: Icon }) => (
        <button onClick={onClick} className={`flex items-center justify-between w-full p-3 mb-2 rounded border ${active ? 'bg-blue-900/50 border-blue-500 text-white' : 'bg-gray-800 border-gray-700 text-gray-400'}`}>
          <div className="flex items-center gap-2"><Icon /> <span>{label}</span></div>
          <span className="font-bold">{active ? 'ON' : 'OFF'}</span>
        </button>
      );

      const threshold = getThresholdForLevel(level);
      const progress = Math.min(100, (levelScore / threshold) * 100);
      const currentWordStr = currentWord.map(b => b.letter).join('');

      return (
        <div className={`h-full w-full flex flex-col relative ${shake ? 'shake' : ''} bg-gray-900 overflow-hidden select-none`}>
          {settings.crt && <div className="scanlines"></div>}

          {/* Top */}
          <div className="flex-none p-2 z-10 bg-gray-900 border-b-2 border-gray-800">
            <div className="flex justify-between items-center mb-2">
              <div className="flex-1">
                <div className="flex items-center gap-2">
                  <a href="index.html" className="text-gray-500 hover:text-white"><IconBack /></a>
                  <h1 className="text-2xl font-black text-blue-500 tracking-tighter leading-none" style={{ fontFamily: '"Black Ops One", cursive' }}>DYSLEXIA</h1>
                </div>
                <div className="text-xs text-gray-400 flex gap-3 items-center mt-1">
                  <span className={levelAnim ? 'level-up-anim font-bold' : ''}>LVL:{level}</span>
                  {/* Level Progress Bar */}
                  <div className="w-24 h-2 bg-gray-800 rounded overflow-hidden border border-gray-700">
                    <div className="h-full bg-blue-500 transition-all duration-300" style={{ width: `${progress}%` }}></div>
                  </div>
                </div>
              </div>
              <div className="flex items-center gap-4">
                <div className="text-right">
                  <div className="text-[10px] text-gray-400 font-bold">HIGH: {highScore}</div>
                  <div className="text-2xl font-bold text-white leading-none">{score}</div>
                  <div className="text-[10px] text-gray-400">SCORE</div>
                </div>
                {gameStarted && !gameOver && (
                  <button onClick={togglePause} className="p-2 bg-gray-800 rounded border border-gray-600 hover:bg-gray-700 text-white">
                    <IconPause />
                  </button>
                )}
              </div>
            </div>
            <div className="flex w-full h-8 md:h-10 bg-black/50 p-1 rounded border border-gray-700 relative overflow-hidden">
              <div className={`absolute inset-0 pointer-events-none transition-opacity duration-200 ${previewIndex > 5 ? 'bg-red-900/30 pulse-red' : 'opacity-0'}`}></div>
              {Array(8).fill(0).map((_, i) => {
                return (
                  <div key={`prev-${i}`} className="flex-1 h-full mx-[2px] rounded flex items-center justify-center border border-gray-800/50 bg-gray-800/30 relative">
                    {previewRow[i] && (
                      <>
                        <div className="absolute inset-0 rounded shadow-inner border-t border-white/20 flex items-center justify-center font-bold" style={{ backgroundColor: previewRow[i].color }}>{previewRow[i].letter}</div>
                        <div className="absolute bottom-0 right-0 text-[8px] leading-none p-0.5 text-black/50 font-bold">{previewRow[i].score}</div>
                      </>
                    )}
                  </div>
                )
              })}
            </div>
          </div>

          {/* Board */}
          <div className="flex-grow relative p-2 z-10 overflow-hidden cursor-crosshair flex items-center justify-center">
            <div className="grid-container">
              {Array.from({ length: ROWS }).map((_, r) => (
                Array.from({ length: COLS }).map((_, c) => {
                  const block = board[r]?.[c];
                  const isSelected = currentWord.some(b => b.id === block?.id);
                  return (
                    <div
                      key={`cell-${r}-${c}`}
                      onClick={() => handleBlockClick(r, c)}
                      className={`
                                                w-full h-full rounded cursor-pointer relative
                                                ${!block ? 'bg-gray-800/20' : ''}
                                                ${isSelected ? 'ring-2 ring-white z-20' : ''}
                                            `}
                    >
                      {block && (
                        <div
                          className="w-full h-full rounded shadow-lg border-t border-white/30 block relative overflow-visible flex items-center justify-center"
                          style={{
                            backgroundColor: block.color,
                            transform: block.isFalling ? 'translateY(-20%)' : 'none',
                            boxShadow: '0 4px 6px rgba(0,0,0,0.5)'
                          }}
                        >
                          <div className="absolute inset-0 rounded bg-gradient-to-br from-white/20 to-black/30 pointer-events-none"></div>
                          <span className="text-xl md:text-2xl font-bold drop-shadow-md">{block.letter}</span>
                          <div className="absolute bottom-0.5 right-1 text-[8px] md:text-[10px] font-bold opacity-70">{block.score}</div>

                          {isSelected && (
                            <div className="absolute inset-0 border-2 border-white rounded selected-ring opacity-50"></div>
                          )}
                        </div>
                      )}
                      {particles.filter(p => p.r === r && p.c === c).map(p => (
                        <div key={p.id} className="particle w-3 h-3 rounded-full z-30" style={{ backgroundColor: p.color, left: '50%', top: '50%', '--tx': p.tx, '--ty': p.ty, boxShadow: `0 0 10px ${p.color}` }}></div>
                      ))}
                      {floatingTexts.filter(t => t.r === r && t.c === c).map(t => (
                        <div
                          key={t.id}
                          className="floating-score"
                          style={{
                            color: t.color,
                            left: `calc(50% + ${t.offsetX}px)`,
                            top: `calc(50% + ${t.offsetY}px)`
                          }}
                        >
                          {t.text}
                        </div>
                      ))}
                    </div>
                  );
                })
              ))}
            </div>
          </div>

          {/* Controls Area: Flexbox for mobile responsiveness */}
          <div className="flex-none bg-gray-900 border-t-2 border-gray-800 flex flex-col p-2 z-20 gap-2">

            {/* Word Input & Submit */}
            <div className="flex gap-2 h-10 w-full">
                <div className="flex-1 bg-black/50 rounded border border-gray-700 flex items-center justify-center relative overflow-hidden">
                    <span className={`text-xl md:text-2xl font-mono font-bold tracking-widest ${currentWord.length >= 3 ? 'text-white' : 'text-gray-500'}`}>
                        {currentWordStr || "TAP LETTERS"}
                    </span>
                    <button
                        onClick={clearWord}
                        className="absolute right-0 top-0 bottom-0 px-2 text-gray-500 hover:text-white"
                        hidden={currentWord.length === 0}
                    >
                        <IconX />
                    </button>
                </div>
                <button
                    onClick={submitWord}
                    disabled={currentWord.length < 3}
                    className="w-24 bg-green-700 border border-green-500 text-white rounded flex items-center justify-center font-bold disabled:opacity-30 disabled:bg-gray-800 disabled:border-gray-700 active:bg-green-600 transition-colors"
                >
                    <IconCheck />
                </button>
            </div>

            {/* Powerups Row */}
            <div className="flex items-center justify-center gap-2">
                <ToolBtn type="radius" icon={IconRadius} label="RAD" />
                <ToolBtn type="col" icon={IconCol} label="COL" />
                <ToolBtn type="row" icon={IconRow} label="ROW" />
                <ToolBtn type="x" icon={IconX} label="X" />
                <ToolBtn type="color" icon={IconColor} label="CLR" />
            </div>
          </div>

          {/* Pause Menu */}
          {isPaused && !gameOver && (
            <div className="absolute inset-0 bg-black/90 z-50 flex flex-col items-center justify-center p-6">
              <h2 className="text-4xl font-black text-white mb-8 tracking-widest">PAUSED</h2>
              <div className="w-full max-w-xs space-y-2 mb-8">
                <SettingBtn label="SOUND" active={settings.sound} onClick={toggleSound} icon={settings.sound ? IconVolume : IconVolumeOff} />
                <SettingBtn label="HAPTICS" active={settings.haptics} onClick={toggleHaptics} icon={IconZap} />
                <SettingBtn label="CRT EFFECT" active={settings.crt} onClick={toggleCRT} icon={IconMonitor} />
                <SettingBtn label="COLOR BLIND" active={settings.colorBlind} onClick={toggleColorBlind} icon={IconEye} />
              </div>
              <div className="flex flex-col gap-4 w-full max-w-xs">
                <button onClick={togglePause} className="w-full py-4 bg-blue-600 hover:bg-blue-500 text-white font-bold rounded border-b-4 border-blue-800 active:border-b-0 active:translate-y-1 transition-all">RESUME</button>
                <button onClick={() => { togglePause(); initGame(); }} className="w-full py-4 bg-red-600 hover:bg-red-500 text-white font-bold rounded border-b-4 border-red-800 active:border-b-0 active:translate-y-1 transition-all">RESTART</button>
                <a href="index.html" className="w-full py-4 bg-gray-700 hover:bg-gray-600 text-white font-bold rounded border-b-4 border-gray-900 active:border-b-0 active:translate-y-1 transition-all text-center">EXIT TO MENU</a>
              </div>
            </div>
          )}

          {/* Game Over */}
          {gameOver && (
            <div className="absolute inset-0 bg-black/80 flex flex-col items-center justify-center z-50 backdrop-blur-sm">
              <h2 className="text-6xl font-black text-red-600 mb-4 tracking-widest">FAIL</h2>
              <p className="text-2xl text-white mb-2 font-mono">LEVEL: {level}</p>
              <p className="text-2xl text-white mb-8 font-mono">SCORE: {score}</p>
              <button onClick={initGame} className="px-10 py-4 text-xl bg-red-600 hover:bg-red-500 text-white font-bold rounded shadow-[0_0_20px_rgba(220,38,38,0.5)] active:scale-95 transition-transform mb-4">RETRY</button>
              <a href="index.html" className="text-gray-400 hover:text-white underline">EXIT TO MENU</a>
            </div>
          )}

          {/* Start Screen */}
          {!gameStarted && !gameOver && (
            <div className="absolute inset-0 bg-black/90 flex flex-col items-center justify-center z-50 px-6">
              <h2 className="text-5xl font-bold text-blue-500 mb-2 text-center">DYSLEXIA</h2>
              <h3 className="text-xl font-bold text-white mb-6 text-center tracking-widest">WORD HUNT</h3>

              {loadingError ? (
                  <div className="text-red-500 font-bold mb-4 text-center">{loadingError}</div>
              ) : !dictLoaded ? (
                  <div className="text-blue-400 font-bold mb-4 animate-pulse">LOADING DICTIONARY...</div>
              ) : (
                <>
                  <div className="w-full max-w-xs bg-gray-800 rounded p-4 border border-gray-700 mb-8">
                    <div className="text-gray-400 text-sm mb-2 text-center font-bold">SELECT START LEVEL</div>
                    <div className="flex items-center justify-between">
                      <button onClick={() => adjustStartLevel(-1)} className="p-2 bg-gray-700 rounded text-white hover:bg-gray-600"><IconMinus /></button>
                      <div className="text-center">
                        <div className="text-4xl font-black text-white">{startLevel}</div>
                        <div className={`text-xs font-bold ${startLevel < 5 ? 'text-green-400' : startLevel < 10 ? 'text-yellow-400' : 'text-red-500'}`}>
                          {startLevel < 5 ? 'NORMAL' : startLevel < 10 ? 'THREATENING' : startLevel < 15 ? 'EXPERT' : 'IMPOSSIBLE'}
                        </div>
                      </div>
                      <button onClick={() => adjustStartLevel(1)} className="p-2 bg-gray-700 rounded text-white hover:bg-gray-600"><IconPlus /></button>
                    </div>
                  </div>
                  <div className="text-base text-gray-300 mb-8 text-center font-mono space-y-2 max-w-xs">
                    <p>Tap letters to form words.</p>
                    <p>Min 3 letters.</p>
                    <p>Power-ups destroy blocks.</p>
                  </div>
                  <button onClick={initGame} className="px-12 py-5 text-xl bg-blue-600 hover:bg-blue-500 text-white font-bold rounded shadow-[0_0_30px_rgba(37,99,235,0.5)] active:scale-95 transition-transform">START</button>
                </>
              )}
              <a href="index.html" className="mt-8 text-gray-500 hover:text-white">BACK TO MENU</a>
            </div>
          )}
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>